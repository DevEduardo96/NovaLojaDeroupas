"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerRoutes = registerRoutes;
const http_1 = require("http");
const supabase_js_1 = require("@supabase/supabase-js");
const mercadopago_1 = require("mercadopago");
const zod_1 = require("zod");
// Fun√ß√£o auxiliar para retry com backoff
async function retryWithBackoff(fn, maxRetries = 3, delay = 1000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        }
        catch (error) {
            if (i === maxRetries - 1)
                throw error;
            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
        }
    }
    throw new Error("Max retries exceeded");
}
// Schema de valida√ß√£o para o endere√ßo
const enderecoSchema = zod_1.z.object({
    cep: zod_1.z.string().min(1, "CEP √© obrigat√≥rio"),
    rua: zod_1.z.string().min(1, "Rua √© obrigat√≥ria"),
    numero: zod_1.z.string().min(1, "N√∫mero √© obrigat√≥rio"),
    complemento: zod_1.z.string().optional(),
    bairro: zod_1.z.string().min(1, "Bairro √© obrigat√≥rio"),
    cidade: zod_1.z.string().min(1, "Cidade √© obrigat√≥ria"),
    estado: zod_1.z.string().min(1, "Estado √© obrigat√≥rio")
});
// Schema simplificado para aceitar exatamente o payload do frontend
const createPaymentSchema = zod_1.z.object({
    carrinho: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.number(),
        name: zod_1.z.string(),
        price: zod_1.z.number(),
        quantity: zod_1.z.number().min(1),
        variacoes: zod_1.z.object({
            cor: zod_1.z.string().optional(),
            tamanho: zod_1.z.string().optional()
        }).optional()
    })),
    nomeCliente: zod_1.z.string().min(1, "Nome √© obrigat√≥rio"),
    email: zod_1.z.string().email("Email inv√°lido"),
    telefone: zod_1.z.string().min(1, "Telefone √© obrigat√≥rio"),
    endereco: enderecoSchema,
    total: zod_1.z.number().min(0.01, "Total deve ser maior que zero")
});
async function registerRoutes(app) {
    // Configura√ß√£o do Supabase
    const supabaseUrl = process.env.SUPABASE_URL || process.env.VITE_SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
    console.log(`üîß Configura√ß√£o do Supabase:`);
    console.log(`URL: ${supabaseUrl ? "‚úÖ Configurada" : "‚ùå N√£o configurada"}`);
    console.log(`KEY: ${supabaseKey ? "‚úÖ Configurada" : "‚ùå N√£o configurada"}`);
    if (!supabaseUrl || !supabaseKey) {
        console.warn(`‚ö†Ô∏è Supabase n√£o configurado. Algumas funcionalidades podem n√£o funcionar.`);
    }
    const supabase = supabaseUrl && supabaseKey ? (0, supabase_js_1.createClient)(supabaseUrl, supabaseKey) : null;
    // Configura√ß√£o do Mercado Pago
    const mercadoPagoAccessToken = process.env.MERCADO_PAGO_ACCESS_TOKEN;
    console.log(`üí≥ Mercado Pago: ${mercadoPagoAccessToken ? "‚úÖ Configurado" : "‚ùå N√£o configurado"}`);
    if (!mercadoPagoAccessToken) {
        console.error(`‚ùå MERCADO_PAGO_ACCESS_TOKEN n√£o configurado. Pagamentos n√£o funcionar√£o.`);
    }
    const client = mercadoPagoAccessToken ? new mercadopago_1.MercadoPagoConfig({
        accessToken: mercadoPagoAccessToken,
        options: { timeout: 10000 }
    }) : null;
    const payment = client ? new mercadopago_1.Payment(client) : null;
    // ROTA: GET /api/status - Status da API
    app.get("/api/status", (req, res) => {
        res.json({
            status: "online",
            timestamp: new Date().toISOString(),
            services: {
                mercadoPago: !!payment,
                supabase: !!supabase
            },
            environment: process.env.NODE_ENV || 'development'
        });
    });
    // MIDDLEWARE DE DEBUG: Capturar EXATAMENTE o que est√° chegando
    app.use("/api/payments/criar-pagamento", (req, res, next) => {
        console.log(`üïµÔ∏è MIDDLEWARE DEBUG - Dados RAW recebidos:`);
        console.log(`üîπ Content-Type: ${req.headers['content-type']}`);
        console.log(`üîπ Body keys: [${Object.keys(req.body).join(', ')}]`);
        console.log(`üîπ Body completo:`, JSON.stringify(req.body, null, 2));
        console.log(`üîπ telefone presente: ${!!req.body.telefone}`);
        console.log(`üîπ endereco presente: ${!!req.body.endereco}`);
        next();
    });
    // ROTA: POST /api/payments/criar-pagamento - Para o frontend - ATUALIZADA
    app.post("/api/payments/criar-pagamento", async (req, res) => {
        try {
            console.log(`üõí Dados recebidos do carrinho:`, JSON.stringify(req.body, null, 2));
            console.log(`üîç Verificando campos obrigat√≥rios:`);
            console.log(`- telefone: ${req.body.telefone ? '‚úÖ' : '‚ùå'} (valor: "${req.body.telefone}")`);
            console.log(`- endereco: ${req.body.endereco ? '‚úÖ' : '‚ùå'} (tipo: ${typeof req.body.endereco})`);
            // Validar dados de entrada
            const validation = createPaymentSchema.safeParse(req.body);
            if (!validation.success) {
                console.error(`‚ùå Erro de valida√ß√£o:`, validation.error.errors);
                console.error(`‚ùå Dados que falharam na valida√ß√£o:`, JSON.stringify(req.body, null, 2));
                return res.status(400).json({
                    error: "Dados inv√°lidos",
                    details: validation.error.errors
                });
            }
            const { carrinho, nomeCliente, email, telefone, endereco, total } = validation.data;
            if (!payment) {
                return res.status(503).json({
                    error: "Servi√ßo de pagamento indispon√≠vel",
                    details: "Mercado Pago n√£o configurado. Configure MERCADO_PAGO_ACCESS_TOKEN."
                });
            }
            // Criar descri√ß√£o rica baseada no carrinho
            const firstItem = carrinho[0];
            let description = firstItem.name;
            // Adicionar varia√ß√µes √† descri√ß√£o se existirem
            if (firstItem.variacoes) {
                const variacoes = [];
                if (firstItem.variacoes.cor)
                    variacoes.push(firstItem.variacoes.cor);
                if (firstItem.variacoes.tamanho)
                    variacoes.push(firstItem.variacoes.tamanho);
                if (variacoes.length > 0) {
                    description += ` - ${variacoes.join(' - ')}`;
                }
            }
            if (carrinho.length > 1) {
                description = `Compra de ${carrinho.length} produtos - ${description} e outros`;
            }
            // Dividir nome em primeiro e √∫ltimo nome
            const nomes = nomeCliente.trim().split(' ');
            const firstName = nomes[0];
            const lastName = nomes.length > 1 ? nomes.slice(1).join(' ') : '';
            // Extrair apenas n√∫meros do telefone para o Mercado Pago
            const telefoneNumeros = telefone.replace(/\D/g, '');
            const paymentData = {
                transaction_amount: total,
                description: description,
                payment_method_id: "pix",
                payer: {
                    email: email,
                    first_name: firstName,
                    last_name: lastName || firstName, // Se n√£o h√° sobrenome, usar o primeiro nome
                    phone: {
                        number: telefoneNumeros
                    }
                },
                metadata: {
                    carrinho: carrinho.map(item => ({
                        produto_id: item.id,
                        nome: item.name,
                        quantidade: item.quantity,
                        preco_unitario: item.price,
                        variacoes: item.variacoes || {}
                    })),
                    cliente: nomeCliente,
                    email: email,
                    telefone: telefone,
                    endereco: endereco,
                    total_itens: carrinho.length
                }
            };
            console.log(`üí≥ Criando pagamento PIX com dados transformados:`);
            console.log(`üìù Descri√ß√£o: "${description}"`);
            console.log(`üë§ Nome: "${firstName}" + "${lastName}"`);
            console.log(`üìû Telefone: "${telefone}" ‚Üí "${telefoneNumeros}"`);
            console.log(`üìç Endere√ßo: ${endereco.cidade}, ${endereco.estado}`);
            console.log(`üí∞ Valor: R$ ${total}`);
            console.log(`üì¶ Itens: ${carrinho.length}`);
            console.log(`üîß Payload Mercado Pago:`, JSON.stringify(paymentData, null, 2));
            const paymentResponse = await retryWithBackoff(() => payment.create({ body: paymentData }), 3, 1000);
            if (!paymentResponse) {
                return res.status(500).json({
                    error: "Erro ao criar pagamento no Mercado Pago"
                });
            }
            console.log(`‚úÖ Pagamento criado no Mercado Pago:`, {
                id: paymentResponse.id,
                status: paymentResponse.status
            });
            // **NOVO: SALVAR PAGAMENTO NO SUPABASE**
            if (supabase) {
                try {
                    console.log(`üíæ Salvando pagamento no Supabase...`);
                    const { data: pagamentoData, error: supabaseError } = await supabase
                        .from('pagamentos')
                        .insert([
                        {
                            pagamento_id: paymentResponse.id?.toString() || '',
                            status: paymentResponse.status,
                            email: email,
                            nome_cliente: nomeCliente,
                            telefone: telefone,
                            valor: total,
                            itens: carrinho.map(item => ({
                                produto_id: item.id,
                                nome: item.name,
                                quantidade: item.quantity,
                                preco_unitario: item.price || 0,
                                preco_total: (item.price || 0) * item.quantity,
                                variacoes: item.variacoes || {}
                            })),
                            endereco_entrega: {
                                cep: endereco.cep,
                                rua: endereco.rua,
                                numero: endereco.numero,
                                complemento: endereco.complemento || null,
                                bairro: endereco.bairro,
                                cidade: endereco.cidade,
                                estado: endereco.estado
                            },
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        }
                    ])
                        .select();
                    if (supabaseError) {
                        console.error(`‚ùå Erro ao salvar no Supabase:`, supabaseError);
                        // N√£o falha a opera√ß√£o, apenas loga o erro
                    }
                    else {
                        console.log(`‚úÖ Pagamento salvo no Supabase:`, pagamentoData?.[0]?.pagamento_id);
                    }
                }
                catch (supabaseInsertError) {
                    console.error(`‚ùå Erro inesperado ao salvar no Supabase:`, supabaseInsertError);
                    // N√£o falha a opera√ß√£o, apenas loga o erro
                }
            }
            else {
                console.warn(`‚ö†Ô∏è Supabase n√£o configurado - pagamento n√£o foi salvo no banco`);
            }
            // Extrair informa√ß√µes do pagamento para retornar ao frontend
            const paymentInfo = {
                id: paymentResponse.id,
                status: paymentResponse.status,
                qr_code: paymentResponse.point_of_interaction?.transaction_data?.qr_code || null,
                qr_code_base64: paymentResponse.point_of_interaction?.transaction_data?.qr_code_base64 || null,
                ticket_url: paymentResponse.point_of_interaction?.transaction_data?.ticket_url || null,
                total: total,
                cliente: nomeCliente,
                email: email,
                telefone: telefone,
                endereco: endereco,
                produtos: carrinho.map(item => ({
                    id: item.id,
                    nome: item.name,
                    quantidade: item.quantity,
                    variacoes: item.variacoes || {}
                }))
            };
            console.log(`‚úÖ Pagamento processado com sucesso:`, {
                id: paymentInfo.id,
                status: paymentInfo.status,
                qr_code_exists: !!paymentInfo.qr_code,
                saved_to_supabase: !!supabase
            });
            res.json(paymentInfo);
        }
        catch (error) {
            console.error(`‚ùå Erro ao criar pagamento:`, error);
            res.status(500).json({
                error: "Erro interno do servidor",
                details: error instanceof Error ? error.message : "Erro desconhecido"
            });
        }
    });
    // WEBHOOK: POST /api/payments/webhook - Recebe notifica√ß√µes do Mercado Pago - ATUALIZADO
    app.post("/api/payments/webhook", async (req, res) => {
        try {
            console.log(`üîî Webhook recebido:`, JSON.stringify(req.body, null, 2));
            const { data, type } = req.body;
            // Verificar se √© uma notifica√ß√£o de pagamento
            if (type === "payment" && data?.id) {
                const paymentId = data.id;
                if (!payment) {
                    console.error(`‚ùå Mercado Pago n√£o configurado para processar webhook`);
                    return res.status(503).json({ error: "Mercado Pago n√£o configurado" });
                }
                // Buscar dados completos do pagamento com retry
                const paymentDetails = await retryWithBackoff(() => payment.get({ id: paymentId }), 3, 2000);
                console.log(`üìä Status do pagamento ${paymentId}:`, paymentDetails.status);
                // **NOVO: ATUALIZAR STATUS NO SUPABASE**
                if (supabase) {
                    try {
                        console.log(`üíæ Atualizando status no Supabase para pagamento ${paymentId}...`);
                        const { error: updateError } = await supabase
                            .from('pagamentos')
                            .update({
                            status: paymentDetails.status,
                            updated_at: new Date().toISOString()
                        })
                            .eq('pagamento_id', paymentId.toString());
                        if (updateError) {
                            console.error(`‚ùå Erro ao atualizar status no Supabase:`, updateError);
                        }
                        else {
                            console.log(`‚úÖ Status atualizado no Supabase: ${paymentDetails.status}`);
                        }
                    }
                    catch (supabaseUpdateError) {
                        console.error(`‚ùå Erro inesperado ao atualizar Supabase:`, supabaseUpdateError);
                    }
                }
                // Se pagamento foi aprovado, entregar os links
                if (paymentDetails.status === "approved") {
                    await processApprovedPayment(paymentDetails, supabase);
                }
            }
            res.status(200).json({ received: true });
        }
        catch (error) {
            console.error(`‚ùå Erro no webhook:`, error);
            res.status(500).json({
                error: "Erro interno",
                details: error instanceof Error ? error.message : "Erro desconhecido"
            });
        }
    });
    // ROTA: GET /api/payments/status/:id - Verificar status do pagamento
    app.get("/api/payments/status/:id", async (req, res) => {
        try {
            const paymentId = req.params.id;
            if (!payment) {
                return res.status(503).json({
                    error: "Servi√ßo de pagamento indispon√≠vel",
                    details: "Mercado Pago n√£o configurado"
                });
            }
            const paymentDetails = await retryWithBackoff(() => payment.get({ id: paymentId }), 3, 1000);
            const response = {
                id: paymentDetails.id,
                status: paymentDetails.status,
                status_detail: paymentDetails.status_detail,
                transaction_amount: paymentDetails.transaction_amount
            };
            // Se aprovado, buscar e incluir links de download
            if (paymentDetails.status === "approved") {
                const downloadLinks = await getDownloadLinks(paymentDetails, supabase);
                response.download_links = downloadLinks;
            }
            res.json(response);
        }
        catch (error) {
            console.error(`‚ùå Erro ao verificar status:`, error);
            res.status(500).json({
                error: "Erro interno",
                details: error instanceof Error ? error.message : "Erro desconhecido"
            });
        }
    });
    // NOVA ROTA: GET /api/payments/pedido/:id - Buscar dados do pedido no Supabase
    app.get("/api/payments/pedido/:id", async (req, res) => {
        try {
            const paymentId = req.params.id;
            if (!supabase) {
                return res.status(503).json({
                    error: "Base de dados indispon√≠vel",
                    details: "Supabase n√£o configurado"
                });
            }
            const { data: pedido, error } = await supabase
                .from('pagamentos')
                .select('*')
                .eq('pagamento_id', paymentId)
                .single();
            if (error || !pedido) {
                return res.status(404).json({
                    error: "Pedido n√£o encontrado",
                    details: error?.message || "Pedido n√£o existe"
                });
            }
            res.json({
                id: pedido.pagamento_id,
                status: pedido.status,
                cliente: pedido.nome_cliente,
                email: pedido.email,
                telefone: pedido.telefone,
                valor: pedido.valor,
                itens: pedido.itens,
                endereco_entrega: pedido.endereco_entrega,
                created_at: pedido.created_at,
                updated_at: pedido.updated_at
            });
        }
        catch (error) {
            console.error(`‚ùå Erro ao buscar pedido:`, error);
            res.status(500).json({
                error: "Erro interno",
                details: error instanceof Error ? error.message : "Erro desconhecido"
            });
        }
    });
    // Fun√ß√£o para processar pagamento aprovado
    async function processApprovedPayment(paymentDetails, supabase) {
        try {
            console.log(`üéâ Processando pagamento aprovado:`, paymentDetails.id);
            if (!supabase) {
                console.error(`‚ùå Supabase n√£o configurado`);
                return;
            }
            const metadata = paymentDetails.metadata;
            const carrinho = metadata?.carrinho || [];
            const email = metadata?.email;
            if (!carrinho.length || !email) {
                console.error(`‚ùå Dados insuficientes no metadata:`, metadata);
                return;
            }
            console.log(`üì¶ Buscando links de download para ${carrinho.length} produtos`);
            // Buscar download_url para cada produto no carrinho
            const downloadLinks = [];
            for (const item of carrinho) {
                try {
                    const { data: produto, error } = await supabase
                        .from("produtos")
                        .select("id, name, download_url")
                        .eq("id", item.produto_id)
                        .single();
                    if (error || !produto) {
                        console.error(`‚ùå Erro ao buscar produto ${item.produto_id}:`, error);
                        continue;
                    }
                    if (produto.download_url) {
                        downloadLinks.push({
                            produto_id: produto.id,
                            nome: produto.name,
                            download_url: produto.download_url,
                            quantidade: item.quantidade,
                            variacoes: item.variacoes || {}
                        });
                        console.log(`‚úÖ Link encontrado para produto ${produto.name}`);
                    }
                    else {
                        console.warn(`‚ö†Ô∏è Produto ${produto.name} n√£o possui download_url`);
                    }
                }
                catch (error) {
                    console.error(`‚ùå Erro ao processar produto ${item.produto_id}:`, error);
                }
            }
            if (downloadLinks.length > 0) {
                console.log(`üìß Enviando ${downloadLinks.length} links para ${email}`);
                // Aqui voc√™ pode implementar o envio por email
                // Por agora, apenas logamos os links que seriam enviados
                console.log(`üîó Links de download para ${email}:`, downloadLinks);
                // TODO: Implementar envio de email com os links
                // await sendDownloadEmail(email, downloadLinks);
                // **NOVO: ATUALIZAR STATUS PARA "ENTREGUE" NO SUPABASE**
                try {
                    const { error: deliveryUpdateError } = await supabase
                        .from('pagamentos')
                        .update({
                        status: 'delivered', // Status customizado para produtos digitais
                        updated_at: new Date().toISOString()
                    })
                        .eq('pagamento_id', paymentDetails.id.toString());
                    if (deliveryUpdateError) {
                        console.error(`‚ùå Erro ao marcar como entregue:`, deliveryUpdateError);
                    }
                    else {
                        console.log(`‚úÖ Pagamento marcado como entregue no Supabase`);
                    }
                }
                catch (error) {
                    console.error(`‚ùå Erro ao atualizar status de entrega:`, error);
                }
            }
            else {
                console.warn(`‚ö†Ô∏è Nenhum link de download encontrado para o pagamento ${paymentDetails.id}`);
            }
        }
        catch (error) {
            console.error(`‚ùå Erro ao processar pagamento aprovado:`, error);
        }
    }
    // Fun√ß√£o para buscar links de download
    async function getDownloadLinks(paymentDetails, supabase) {
        if (!supabase)
            return [];
        try {
            const metadata = paymentDetails.metadata;
            const carrinho = metadata?.carrinho || [];
            const downloadLinks = [];
            for (const item of carrinho) {
                const { data: produto, error } = await supabase
                    .from("produtos")
                    .select("id, name, download_url")
                    .eq("id", item.produto_id)
                    .single();
                if (!error && produto?.download_url) {
                    downloadLinks.push({
                        produto_id: produto.id,
                        nome: produto.name,
                        download_url: produto.download_url,
                        variacoes: item.variacoes || {}
                    });
                }
            }
            return downloadLinks;
        }
        catch (error) {
            console.error(`‚ùå Erro ao buscar links:`, error);
            return [];
        }
    }
    const httpServer = (0, http_1.createServer)(app);
    return httpServer;
}